# =============================================================================
# "server.R" file     
#
# required file for Shiny Application
#
# renders all visual object (maps, charts, help boxes)
# modifies inputs through interativity 
#  
# Michael Samuel
# 2018
#
# =============================================================================
# Load functions that determine what to show based on current tab selection
source(paste0(myPlace,"/myFunctions/inputFunctions/input_functions.R"))

shinyServer(function(input, output,session) {

  # Store current navID (big tabs) and tabID (subtabs) for use throughout Server
  current <- reactiveValues()
  
  # Update current nav and tab values any time tab selection changes
  observe({
    current$nav = input$navsID
    current$tab <- switch(current$nav,
                          "maps" = input$mapsID,
                          "ranks" = input$ranksID,
                          "trends" = input$trendsID,
                          "sdohHospitals" = input$sdohHospitalsID,
                          current$nav)
    print(current$tab)
    updateTabItems(session, "plotsMenuItems", "tabInputs")  # Always set menu to tabInputs, not tabInfo
  })
  
  # Update sidebar inputs and text based on current tab selection
  observe({
    if (current$nav %in% c("home", "abouts")) {
      hideAllInputs()
      hide("plotsMenu")
      show("textHomeTab")
    } else {
      show("plotsMenu")
      show("textNotHomeTab")
      updateInputsOnTabId(current$tab, input$myGeo, input$myLHJ, input$myMeasure, input$myMultiRace)
      hide("textHomeTab")
    }
  })

  # showModal(
  #   modalDialog(
  #     title = HTML("<h3><center>We are looking for feedback from users like you!</center></h3>"),
  #     HTML("<ul>
  #      <li>What you are using the information on the site to do?</li>
  #          <li>What do you like? What don't you like?</li>
  #          <li>What is missing that you'd like to see?</li></ul> <h1> <center><a href='mailto:michael.samuel@cdph.ca.gov?subject=CCHVIz feedback'>Email us to share your ideas</a></h1>"),
  #     footer = NULL,
  #     easyClose = T
  #     # ,
  #     # footer = modalButton("Close")
  #   )
  # )
  #
  #


# -------------------------------------------------------------------------------

# "onclick" is a function from shinyjs package
# used here to move to specified tab when specified image in clicked
# first perameter is id associated with images from home page main pannel
#  see ui.R  "tabPanel("Home Page"..."

  # Function to update panel selection (or do anything else..) on img click
updatePanels <- function(navsID, tabID="") {
  updateTabsetPanel(session, inputId="navsID", selected = navsID)
  updateTabsetPanel(session, inputId=paste0(navsID, "sID"),   selected=tabID)
}

onclick("map1I",      updatePanels(navsID = "maps",          tabID = "interactiveMapTab"))
onclick("map2I",      updatePanels(navsID = "maps",          tabID = "staticMapTab"))  # static map currently not implemented, so just goes to interactive
onclick("rankcauseI", updatePanels(navsID = "ranks",         tabID = "rankByCauseTab"))
onclick("ranktableI", updatePanels(navsID = "dataTableTab"))
onclick("rankgeoI",   updatePanels(navsID = "ranks",         tabID = "rankByGeographyTab"))
onclick("trendI",     updatePanels(navsID = "trends",        tabID = "trendTab"))
onclick("scatterI",   updatePanels(navsID = "sdohHospitals", tabID = "socialDeterminantsTab"))

  
# shinyjs::onclick("map1I",     updateTabsetPanel(session,inputId="ID",selected="22"))  
# shinyjs::onclick("map2I",     updateTabsetPanel(session,inputId="ID",selected="23"))  
# shinyjs::onclick("rankcauseI",updateTabsetPanel(session,inputId="ID",selected="33"))  
# shinyjs::onclick("ranktableI",updateTabsetPanel(session,inputId="ID",selected="45"))  
# shinyjs::onclick("rankgeoI",  updateTabsetPanel(session,inputId="ID",selected="44"))  
# shinyjs::onclick("trendI",    updateTabsetPanel(session,inputId="ID",selected="55"))  
# shinyjs::onclick("scatterI",  updateTabsetPanel(session,inputId="ID",selected="66"))  

# -------------------------------------------------------------------------------

# function used below as "shortcut" for formating each Modal
myModal <- function(whatInfo) {
  showModal(modalDialog(HTML(whatInfo),
            easyClose = TRUE,
            footer = modalButton("Close")
))}

# generates help "objects" used for "drop down" help buttons
# single argument to each HTML function is a text object (vector of length 1)
#   generated by source("...AppText.txt) in Global.R
observeEvent(input$causeHelp,     {myModal(causeHelp)})
observeEvent(input$cutmethodHelp, {myModal(cutmethodHelp)})
observeEvent(input$stateCutHelp,  {myModal(stateCutHelp)})
observeEvent(input$measureHelp,   {myModal(measureHelp)})
observeEvent(input$levelHelp,     {myModal(levelHelp)})

# generates help "objects" used for tab help buttons, as above
tabHelpList <- list("dataTableTab" = conditionTableTab,
                    "interactiveMapTab" = mapTab,
                    "socialDeterminantsTab" = sdohTab,
                    "trendTab" = trendTab,
                    "rankByCauseTab" = conditionTab,
                    "rankByGeographyTab" = rankGeoTab,
                    "rankByCauseAndSexTab" = conditionSexTab)

whoNeedsHelp <- reactive({
  if (current$tab %in% names(tabHelpList)) {
    return(tabHelpList[[current$tab]])
  } else { return("Help Info is not yet available for this tab.") }
})

# tabHelp as a Menu Item and output variable
observeEvent(input$plotsMenuItems, {
  if (input$plotsMenuItems == "tabInputs") {
    hide("tabHelpInfo")
    show("inputs")
  } else {
    show("tabHelpInfo")
    hide("inputs")
  }
})

output$currTabInfo <- renderText(whoNeedsHelp())

# tabHelp as a button
observeEvent(input$tabHelp, {myModal(whoNeedsHelp())})

# observeEvent(input$mapTab,            {myModal(mapTab)})
# observeEvent(input$conditionTab,      {myModal(conditionTab)})
# observeEvent(input$conditionTableTab, {myModal(conditionTableTab)})
# observeEvent(input$conditionSexTab,   {myModal(conditionSexTab)})
# observeEvent(input$rankGeoTab,        {myModal(rankGeoTab)})
# observeEvent(input$trendTab,          {myModal(trendTab)})
# observeEvent(input$sdohTab,           {myModal(sdohTab) })

# generates text "object" used for news you can use buttons, from "...newsUseText.txt" as above
observeEvent(input$newsUse,           {myModal(newsUse)})

# -------------------------------------------------------------------------------
# TODO figure out what these observeEvents should achieve & simplify

# create "empty" reactive value
#  then fill it with current "myCause" selection for use elsewhere
current_Cause <- reactiveVal(NULL)
observeEvent(input$myCAUSE, { current_Cause(input$myCAUSE) })

# change "myCause" list based on geographic level selected, and specifiy current
#   selection if Community or County level
observeEvent(input$myGeo, {
    if(input$myGeo=="Census Tract"){updateSelectInput(session, "myCAUSE", choices = bigCode ) }
    if(input$myGeo=="Community")   {updateSelectInput(session, "myCAUSE", choices = phCode, selected=current_Cause()) }
    if(input$myGeo=="County")      {updateSelectInput(session, "myCAUSE", choices = fullList,selected=current_Cause()) }
})


# if myLHJ is not STATE (e.g. "CALIFORNIA"), then myGeo is "Community" so
#  that county map will not show just overall county data

# Can combine these 2 into 1:
observeEvent(input$myLHJ, {
  if(input$myLHJ != STATE & current$tab %in% c("interactiveMapTab","staticMapTab")){updateSelectInput(session, "myGeo", selected = "Community") }
})

observeEvent(current$tab, {
  if(input$myLHJ != STATE & current$tab %in% c("interactiveMapTab","staticMapTab")){updateSelectInput(session, "myGeo", selected = "Community") }
})

# Hard wire... Trend only COUNTY for now
observeEvent(current$tab,{
  if(current$tab %in% c("trendTab") )
  {updateSelectInput(session, "myCAUSE", choices = fullList,selected=current_Cause()  )}
})

# TODO These tabs don't have myGeo input?
observeEvent(current$tab,{
  if(current$tab %in% c("rankByGeographyTab","raceTrendTab","educationTrendTab") &  input$myGeo=="Community")
  {updateSelectInput(session, "myCAUSE", choices = phCode,selected=current_Cause()  )}
})

observeEvent(current$tab,{
  if(current$tab %in% c("interactiveMapTab","staticMapTab")  & input$myGeo=="Census Tract" )
  {updateSelectInput(session, "myCAUSE", choices = bigCode )}
})


# not used now, but saved as examples of other reactivity
# observeEvent(input$ID,{
#  if(input$ID %in% c(33,34,44,45,55))
#   {updateSelectInput(session, "myLHJ", choices = lList, selected=current_LHJ())}
#  if(input$ID %in% c(22,23)  & current_LHJ() != "CALIFORNIA")
#   {updateSelectInput(session, "myLHJ", choices = lListNoState, selected=current_LHJ())}
#  if(input$ID %in% c(22,23)  & current_LHJ() == "CALIFORNIA")
#   {updateSelectInput(session, "cZoom", selected=FALSE) }
#
# )
#for two input use:
# observeEvent(input$test1 | input$test2, {
#    if(input$test1==0 && input$test2==0){







#--------------------------------------------------------------------------------
# Render Application Maps and Charts --------------------------------------------



output$cbdMapTL     <- renderLeaflet(cbdMapXLeaf(input$myLHJ, input$myCAUSE, input$myMeasure,      input$myYear, input$mySex,input$myStateCut, input$myGeo, input$myLabName, input$myCutSystem))


# ALL HELL BREAKS LOOSE WITH dbounce
# use dbounce() below to "delay" rendering of may to avoid temporary error
# output$cbdMapTL     <- debounce(renderLeaflet(cbdMapXLeaf(input$myLHJ, input$myCAUSE, input$myMeasure,      input$myYear, input$mySex,input$myStateCut, input$myGeo, input$myLabName, input$myCutSystem)),2000)

# make's sure inputs are Truthy (read ?isTruthy)
# mapJunk          <- reative({
#   req(input$myLHJ, input$myCAUSE, input$myMeasure,      input$myYear, input$mySex,input$myStateCut, input$myGeo, input$myLabName, input$myCutSystem)
#   cbdMapXLeaf(input$myLHJ, input$myCAUSE, input$myMeasure,      input$myYear, input$mySex,input$myStateCut, input$myGeo, input$myLabName, input$myCutSystem)})



   mapJunk          <- reactive(cbdMapXLeaf(input$myLHJ, input$myCAUSE, input$myMeasure,      input$myYear, input$mySex,input$myStateCut, input$myGeo, input$myLabName, input$myCutSystem))

  output$cbdMapTL   <- renderLeaflet(mapJunk())


  output$mapFigureI <- downloadHandler(filename=function(){paste0("MAP2",".png")},content = function(file) {
  png(file, width = 10, height = 7, units = "in", pointsize = 10,res=100)
  print(mapJunk())
  dev.off()
})


# output$mapFigureI <- downloadHandler(filename=function(){paste0("MAP2",".png")},content = function(file) {
#   png(file, width = 10, height = 7, units = "in", pointsize = 10,res=100)
#   print(cbdMapXLeaf(input$myLHJ, input$myCAUSE, input$myMeasure,      input$myYear, input$mySex,input$myStateCut, input$myGeo, input$myLabName, input$myCutSystem))
#   dev.off()
# })



output$mapFigure <- downloadHandler(filename=function(){paste0("MAP",".png")},content = function(file) {
  png(file, width = 10, height = 7, units = "in", pointsize = 10,res=100)
  print(cbdMapXStat(input$myLHJ, input$myCAUSE, input$myMeasure,      input$myYear, input$mySex,input$myStateCut, input$myGeo, input$myLabName, input$myCutSystem))
  dev.off()
})


output$rankCauseFigure <- downloadHandler(filename=function(){paste0("CAUSE",".png")},content = function(file) {
  png(file, width = 10, height = 7, units = "in", pointsize = 10,res=100)
  print(rankCause(input$myLHJ,                input$myMeasureShort, input$myYear, input$mySex, input$myLev, input$myN))
  dev.off()
})


output$cbdMapTS     <- renderPlot(   cbdMapXStat(input$myLHJ, input$myCAUSE, input$myMeasure,      input$myYear, input$mySex,input$myStateCut, input$myGeo, input$myLabName, input$myCutSystem))


output$rankCause    <- renderPlot(     rankCause(input$myLHJ,                input$myMeasureShort,  input$mySex, input$myLev, input$myN,input$myYear))
output$rankCauseSex <- renderPlot(  rankCauseSex(input$myLHJ,                input$myMeasure     , input$myYear,              input$myLev, input$myN))
output$rankGeo      <- renderPlot(       rankGeo(input$myLHJ, input$myCAUSE, input$myMeasure,      input$myYear, input$mySex, input$myCI,input$myRefLine))


# Trend ----------------------------------------------------------------------------------------------------

trendStep     <- reactive(trend(input$myLHJ, input$myCAUSE, input$myMeasure, input$myYearGrouping))
output$trend  <- renderPlot(trendStep()$plot)

#output$trend        <- renderPlotly(trendStep()$plot)


output$trendPNG <- downloadHandler(filename=function(){paste0("trend",".png")},content = function(file) {
  png(file, width = 10, height = 7, units = "in", pointsize = 10,res=100)
  print(trendStep()$plot)
  dev.off()
})

output$trendData <- downloadHandler(
  filename = function() {
    paste("data-", Sys.Date(), ".csv", sep="")
  },
  content = function(file) {
    write.csv(trendStep()$data, file)
  }
)

# IHME ----------------------------------------------------------------------------------------------------
# Arrows Data and plot
output$arrowsTitles <- renderText({
  paste0('<div style="margin-bottom:-1em;">',
         '<h4 style="white-space:nowrap;">', paste(METRICS[[input$metric]]$name, "of", MEASURES[[input$measure]]$short_name, "for", SEXES[[input$sex]], "in all of California"), '</h4>',
         '<div style="float:left; margin-left: 70px; font-weight: bold;">', input$yearRange[1], " Rankings", '</div>',
         '<div style="position:relative; left: 250px; font-weight: bold;">', input$yearRange[2], " Rankings", '</div>',
         '</div>')
})

output$arrowsLegend <- renderText({   # TODO: lineheight styling, legend text reactive
  paste0('<div style="overflow:hidden;">',
         '<div style="background-color: #C6E2FF; float:left; margin-right:5px; border: 1px solid black; height: 15px; width:15px;"> </div>',
         '<div style="line-height:1; display: block;">', "Legend box text", '</div>',
         '<div style="background-color: #E9A291; float:left; margin-right:5px; border: 1px solid black; height: 20px; width:15px;"> </div>',
         '<div style="line-height:1; display: block;">', "Legend box text numero dos", '</div>',
         '</div>'
  )
  
})

output$network <- renderVisNetwork({
  nodes_and_edges <- create_nodes(input$level, input$measure, input$sex, input$metric,
                                  input$yearRange[1], input$yearRange[2], input$display)
  vis_network(nodes_and_edges, input$display)
})

# RiskByCause Data and plot
FilteredRiskByCause <- reactive({
  return(FilterRiskByCause( input$level, input$year, input$sex, input$metric, input$measure))
})

output$riskByCause <- renderPlotly({
  RiskByCausePlot(FilteredRiskByCause())
})


# ---------------------------------------------------------------------------------------------------------


output$trendAge   <- renderPlot(         trendAge(input$myLHJ, input$myCAUSE, input$myLogTrans))

output$trendRace    <- renderPlot(         trendRace(input$myLHJ, input$myCAUSE, input$myMeasure,input$myLogTrans,input$myMultiRace))

# ---------------------------------------------------------------------------------------------------------

disparityStep <- reactive(disparity(input$myLHJ, input$myCAUSE))

output$trend  <- renderPlot(trendStep()$plot)

myPlotly <- FALSE
if (!myPlotly)  output$disparityRace <- renderPlot(disparityStep())
if ( myPlotly)  output$disparityRace <- renderPlotly(disparityStep())


# ---------------------------------------------------------------------------------------------------------



output$trendEducation    <- renderPlot(         trendEducation(input$myLHJ, input$myCAUSE, input$mySex,input$myMeasure,input$myLogTrans))



# output$OSHPD1    <- renderPlot(         oshpdPlot1(input$myLHJ, input$myOSHPDtype, input$mySex, input$myN))
output$OSHPD1    <- renderPlot(         oshpdPlot1(input$myLHJ, input$myOSHPDtype, input$mySex, input$myN, input$myVar))

output$OSHPD2    <- renderPlotly(         oshpdPlot2(input$myLHJ, input$myOSHPDtype, input$mySex, input$myN, input$myVar))


output$mdcdrg   <- renderPlot(mdc_drg_plot(input$myLHJ, input$myOSHPDtype_mdcdrg, input$mySex, input$myN, input$myVar))

output$any_primary <- renderPlot(anyprimary1(input$myLHJ, input$mySex, input$myprimetype))

output$oshpdmap <- renderPlot(cbdOSHPDMap(input$myLHJ, input$mySex, input$myCause,input$myGeo))

output$scatter      <- renderPlotly( scatterSDOH(             input$myCAUSE, input$myMeasure,                    input$mySex,                  input$myGeo,input$myX))

output$rankCauseT   <- renderDataTable(rankCauseTab(input$myLHJ, input$myYear, input$mySex),
                                     option=list(columnDefs=list(list(targets=3:5, class="dt-right")), pageLength = 60)) #DT::


output$lifeTable  <- renderPlot(         LEtrend(input$myLHJ))



# Generate labels and titles for maps and charts --------------------------------

sexLabel   <- renderText({if (input$mySex == "Total")  sexLabel  <- ""      else sexLabel  <- paste0(", among ",input$mySex,"s")})
geoLabel   <- renderText({if (input$myLHJ==STATE)      geoLab    <- ""      else geoLab    <- paste0(" in ",input$myLHJ)})
timeLabel  <- renderText({if (input$myGeo != "County") timeLabel <- yearGrp else timeLabel <- paste(input$myYear)})

output$map_title <- renderUI({h4(strong(
                    HTML(paste0(   deathMeasuresNames[deathMeasures == input$myMeasure],
                                   " from ",
                                   fullCauseList[fullCauseList[,"LABEL"]==input$myCAUSE,"nameOnly"][1],     # FIX this [1] here now since second element is NA
                                   " in ",span(timeLabel(),style="color:blue"),
                                   " by ",input$myGeo,
                                   sexLabel(), geoLabel(),
                                   sep = " ")))) })

# END of shinyServer ---------------------------------------------------------

}) 

# -- END ----------------------------------------------------------------------


# previously needed - keeping just in case....
#yearGrp <- "2013-2017"   # why doesn't it find this from global?